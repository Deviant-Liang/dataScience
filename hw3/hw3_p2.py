# -*- coding: utf-8 -*-
"""hw3_p2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qmxQ1Ov6dcS7LBNok4b95kgkDYRAduGo
"""

import pandas as pd
import numpy as np
from statsmodels.tsa.seasonal import seasonal_decompose
  
from google.colab import drive
drive.mount('/content/drive/')

f_index = open('drive/MyDrive/hw3_prob1&2/index.txt')
gene = np.loadtxt('drive/MyDrive/hw3_prob1&2/gene.txt', dtype=float)
label = np.loadtxt('drive/MyDrive/hw3_prob1&2/label.txt', dtype=float)
feature_names = f_index.read().split('\n')

f_index.close()
label[label > 0] = 0
label[label < 0] = 1
gene = gene.transpose()

X, y = gene, label
#print(label)

from sklearn import datasets

data=datasets.load_diabetes()

class LiearRegressionPSO:
  def __init__(self):
    self.x , self.y = gene, label
    self.w = 0.8
    self.c1 = 2
    self.c2 = 2
    self.r1 = 0.5
    self.r2 = 0.5
    self.pN = 30 
    self.dim = 2001 
    self.max_iter = 2000 
    self.X = np.zeros((self.pN, self.dim)) 
    self.V = np.zeros((self.pN, self.dim))
    self.pbest = np.zeros((self.pN, self.dim)) 
    self.gbest = np.zeros((1, self.dim)) 
    self.p_fit = np.zeros(self.pN) 
    self.fit = 100000000 
  def costFunction(self,x):
    h=np.sum(x.T*np.insert(self.x,0,1,axis=1),axis=1)-self.y
    diff=h**2
    return diff.sum()/self.x.shape[0]
  def initPopulation(self):
    for i in range(self.pN):
      for j in range(self.dim):
        self.X[i][j] = np.random.uniform(0, 1)
        self.V[i][j] = np.random.uniform(0, 1)
        self.pbest[i] = self.X[i]
        cost = self.costFunction(self.X[i])
        self.p_fit[i] = cost
        if (cost < self.fit):
          self.fit = cost
          self.gbest = self.X[i]
  def fitModel(self):
    self.initPopulation()
    costVale=[]
    for i in range(self.max_iter):
      for j in range(self.pN):
        cost= self.costFunction(self.X[j])
        if (cost<self.p_fit[j]):
          self.pbest[j]=self.X[j]
          self.p_fit[j]=cost
        if (self.p_fit[j]<self.fit):
          self.gbest= self.X[j]
          self.fit= self.p_fit[j]
    for k in range(self.pN):
      self.V[k]= self.w*self.V[k]+self.c1*self.r1*(self.pbest[k]-self.X[k])+self.c2*self.r2*(self.gbest-self.X[k])
      self.X[k]= self.X[k]+self.V[k]
      costVale.append(self.fit)
      return self.gbest ,costVale
  def predict(self,x):
    w ,cost= self.fitModel()
    return w[0]+np.sum(w[1:].reshape(-1,1).T*x ,axis=1)

temp = LiearRegressionPSO()
print(temp.predict(gene[0]))
print(temp.gbest)
import matplotlib.pyplot as plt

gbest = temp.gbest[temp.gbest > 0.9]
m = len(gbest)

s = sorted(range(len(temp.gbest)), key=lambda k: temp.gbest[k])
#print(s[-m:])

for i in range(1812,1999):
  print(feature_names[s[i]])